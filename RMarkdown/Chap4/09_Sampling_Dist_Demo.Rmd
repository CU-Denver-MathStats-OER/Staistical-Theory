---
title: 'Worksheet 09: Sampling Distributions'
output:
  html_document:
    df_print: paged
    fig_height: 3
    fig_width: 4
---

# Sampling Distributions

---

<blockquote style="border: 2px solid #666; padding: 10px; background-color: #E5E4E2;">
**<font color="#0000FF">Statistical inference</font>** is the process of drawing conclusions about the entire population based on information in a sample.

A **<font color="#0000FF">sampling distribution</font>** is the distribution of sample statistics (such as a mean, proportion, median, maximum, etc.) computed for different samples of the same size from the same population. A sampling distribution shows us how the sample statistic varies from sample to sample.
</blockquote>

## Question 1: Sampling from a Normal Population  

---

Let $X$ denote the distribution of BMI of all adult men. We can approximate this distribution by $X \sim N(26, 4)$. 

a. Interpret the code below. Add comments to explain what each command will do. Then run the code.

```{r eval=FALSE}
# Add your comment here
bmi <- seq(26-4*4, 26+4*4, length=100)

# Add your comment here
pdf.bmi <- dnorm(bmi, 26, 4)

# Add your comment here
plot(bmi, pdf.bmi, 
     type="l", lty=1, # type="l" draws line lty=1 is solid line
     xlab="Body Mass Index (BMI)",
  ylab="Density", main="Distribution of Population")
```

### Student solution to 1a: (enter comments in code cell above)

---

<br>
<br>
<br>
<br>


b.  A sample of $n=4$ adult men are randomly selected. The mean BMI of the sample is calculated:
$$ \bar{x} = \frac{x_1 + x_2 + x_3+x_4}{4}.$$
Then another random sample of $n=4$ adult men are randomly selected, and again the mean BMI of this sample is computed. This is repeated 1000 times (each sample size $n=4$), and the sampling distribution for the mean BMI can be constructed with the code below:

```{r eval=FALSE}
# creates an empty vector to store results
n4.bmi.bar <- numeric(1000) 

# A for loop that generates 1000 random samples 
# Each size n=4, and calculates the sample mean.
for (i in 1:1000)
{
  n4.bmi.sample <- rnorm(4, 26, 4) #Randomly picks 4 values from N(26,4)
  n4.bmi.bar[i] <- mean(n4.bmi.sample)
}

# Plot the sampling distribution
hist(n4.bmi.bar, xlim = c(14, 38), 
     xlab = "Mean BMI of Sample",
     main = "Sampling Distribution of Mean BMI for n=4",
     xaxt='n')
axis(1, at=seq(14, 38, 4), pos=0)
abline(v = 26, col = "red", lwd = 2, lty = 2)
```

c. In the R code block below, enter commands to compute the center (as measured by the mean) and spread (as measured by the standard deviation) of the sampling distribution when $n=4$.

```{r eval=FALSE}
mean(??)
sd(??)
```

d. Repeat parts (b) and (c) if we increase the size of the samples from $n=4$ to $n=9$. **Try to edit the code below (which is from parts b and c) rather than write code from scratch.**

```{r eval=FALSE}
# creates an empty vector to store results
n4.bmi.bar <- numeric(1000) 

# A for loop that generates 1000 random samples 
# Each size n=4, and calculates the sample mean.
for (i in 1:1000)
{
  n4.bmi.sample <- rnorm(4, 26, 4) #Randomly picks 4 values from N(26,4)
  n4.bmi.bar[i] <- mean(n4.bmi.sample)
}

# Plot the sampling distribution
hist(n4.bmi.bar, xlim = c(14, 38), 
     xlab = "Mean BMI of Sample",
     main = "Sampling Distribution of Mean BMI for n=4",
     xaxt='n')
axis(1, at=seq(14, 38, 4), pos=0)
abline(v = 26, col = "red", lwd = 2, lty = 2)
```

```{r eval=FALSE}
mean(??)
sd(??)
```

e. Repeat parts (b) and (c) if we increase the size of the samples to $n=16$. **As with part (d), edit the code below (which is from parts b and c) rather than write code from scratch.**

```{r eval=FALSE}
# creates an empty vector to store results
n4.bmi.bar <- numeric(1000) 

# A for loop that generates 1000 random samples 
# Each size n=4, and calculates the sample mean.
for (i in 1:1000)
{
  n4.bmi.sample <- rnorm(4, 26, 4) #Randomly picks 4 values from N(26,4)
  n4.bmi.bar[i] <- mean(n4.bmi.sample)
}

# Plot the sampling distribution
hist(n4.bmi.bar, xlim = c(14, 38), 
     xlab = "Mean BMI of Sample",
     main = "Sampling Distribution of Mean BMI for n=4",
     xaxt='n')
axis(1, at=seq(14, 38, 4), pos=0)
abline(v = 26, col = "red", lwd = 2, lty = 2)
```

```{r eval=FALSE}
mean(??)
sd(??)
```

## Question 2: Sampling from a Skewed Population  

Let $X$ denote the distribution of the time (in minutes) between successive eruptions (called the wait time) of a certain geyser that is modeled by $X \sim \mbox{Exp} \big( \frac{1}{40} \big)$.

library(shiny) # Start script by loading the Shiny package with the command
library(car)

```{echo = FALSE}
# Define UI for app that draws a histogram
ui <- fluidPage(
  titlePanel("Sampling Distribution of Wait Time"), # App title
  sidebarLayout( # Begin Sidebar layout 
    sidebarPanel(  # Sidebar panel for inputs
      sliderInput(inputId = "nsamp", # Create Input Object: Number in each sample
                  label = "Size of Sample", 
                  min = 1,
                  max = 50,
                  value = 4) # Initial value of slider
     ),
    mainPanel( # Begin main panel for displaying outputs
      plotOutput(outputId = "distPlot") # Output: Histogram
    )
  )
)


# Server function
server <- function(input, output) {
  # creates an empty vector to store results
  wait.mean <- numeric(200) 
  
output$distPlot <- renderPlot({
  par(mfrow = c(1, 2))
 
  # A for loop that generates 1000 random samples 
  # Each size n=4, and calculates the sample mean.
  for (i in 1:200)
  {
    wait.sample <- rexp(input$nsamp, 1/40) #Randomly picks 4 values from Exp(1/40)
    wait.mean[i] <- mean(wait.sample)
  }
  
  
  par(mfrow = c(1, 2))
  qqPlot(wait.mean) # uses car library 
#  qqnorm(wait.mean, ylab = "Residuals")
 # qqline(wait.mean)
  
  # Plot the sampling distribution
  hist(wait.mean, xlim = c(0, 100), 
       xlab = "Mean Wait Time of Sample (in min)",
       main = "Sampling Distribution of Mean Wait Time",
       xaxt='n')
  axis(1, at=seq(0, 100, 10), pos=0)
  abline(v = 40, col = "red", lwd = 2, lty = 2)
  
  #print("The center of the sampling distribution is", round(mean(bmi.mean),2),
  #      "\n \n The standard error is", round(sd(bmi.mean),4))
  }) # End renderPlot

} #End server

shinyApp(ui = ui, server = server) # End with a call to `shinyApp`
```


a. Interpret and run the code below to create a graph of the pdf for the distribution of $X$, the wait time between all eruptions of a certain geyser.

```{r eval=FALSE}
# load possible wait times.
wait.time <- seq(0, 100, length=200)

# Compute the value of f(x) of each wait time x if we assume
# the times are exponentially distributed with mean 40 min.
pdf.wait.time <- dexp(wait.time, 1/40)

# Plot bmi on x-axis and the value of pdf, f(x) on y-axis.
plot(wait.time, pdf.wait.time, 
     type="l", lty=1,         # type="l" draws line lty=1 is solid line
     xlab="Wait time (in minutes)",
  ylab="Density", main="Distribution of Population")
```

b.  A sample of $n=4$ wait times are randomly selected and the sample  mean wait mean is calculated. This is repeated until 1000 random samples each size $n=4$ are selected.**Edit the code below (which is from question 1 part b) rather than write code from scratch.** 

```{r eval=FALSE}
# creates an empty vector to store results
n4.bmi.bar <- numeric(1000) 

# A for loop that generates 1000 random samples 
# Each size n=4, and calculates the sample mean.
for (i in 1:1000)
{
  n4.bmi.sample <- rnorm(4, 26, 4) #Randomly picks 4 values from N(26,4)
  n4.bmi.bar[i] <- mean(n4.bmi.sample)
}

# Plot the sampling distribution
hist(n4.bmi.bar, xlim = c(14, 38), 
     xlab = "Mean BMI of Sample",
     main = "Sampling Distribution of Mean BMI for n=4",
     xaxt='n')
axis(1, at=seq(14, 38, 4), pos=0)
abline(v = 26, col = "red", lwd = 2, lty = 2)
```

c. In the R code block below, enter commands to compute the center (as measured by the mean) and spread (as measured by the standard deviation) of the sampling distribution when $n=4$.

```{r eval=FALSE}
mean(??)
sd(??)
```

d. Repeat parts (b) and (c) if we increase the size of the samples from $n=4$ to $n=9$. **Edit the code you used in parts b and c of question 2 rather than write code from scratch.**

e. Repeat parts (b) and (c) if we increase the size of the samples to $n=16$. **Edit the code you used in parts b and c of question 2 rather than write code from scratch.**

## Question 3: Sampling from a Bimodal Population  
The dataset **quakes** in R has the locations of 1000 seismic events that occurred near Fiji since 1964 with body wave magnitude (mb)  $> 4.0$. Assume this data represents the population of all such earthquakes near Fiji since 1964. Let $X$ denote the distribution of the depths (in km) where all such earthquakes occurred. Note this data is approximately **bimodal**. 


a. Calculate the mean and standard deviation of the population.

```{r eval=FALSE}

```

b. Interpret and run the code below to create a histogram to show the distribution of the depths (variable is called **depth**) of all earthquakes in the dataset.

```{r eval=FALSE}
hist(quakes$depth, 
     xlab = "Depth (in km)",
     main = "Distribution of Population",
     xaxt='n')
axis(1, at=seq(0, 700, 100), pos=0)
abline(v = mean(quakes$depth), col = "red", lwd = 2, lty = 2)
```

c.  A sample of $n=4$ earthquakes are randomly selected and the mean depth of the quakes in the sample is calculated. This is repeated 1000 times (each sample size $n=4$), and the sampling distribution for the mean depth can be constructed with the code below:

```{r eval=FALSE}
# creates an empty vector to store results
n4.quake.bar <- numeric(1000) 

# A for loop that generates 1000 random samples 
# Each size n=4, and calculates the sample mean.
for (i in 1:1000)
{
  n4.quake.sample <- sample(quakes$depth, 4, replace=FALSE) #Randomly picks 4 depths
  n4.quake.bar[i] <- mean(n4.quake.sample)
}

# Plot the sampling distribution
hist(n4.quake.bar, xlim = c(0, 700), 
     xlab = "Mean Depth of Sample (in km)",
     main = "Sampling Distribution of Mean Depth for n=4",
     xaxt='n')
axis(1, at=seq(0, 700, 100), pos=0)
abline(v = mean(quakes$depth), col = "red", lwd = 2, lty = 2)
```

d. In the R code block below, enter commands to compute the center (as measured by the mean) and spread (as measured by the standard deviation) of the sampling distribution when $n=4$.

```{r eval=FALSE}
mean(??)
sd(??)
```

e. Repeat parts (c) and (d) if we increase the size of the samples to $n=9$. **Edit the code used in parts c and d rather than write code from scratch.**

f. Repeat parts (c) and (d) if we increase the size of the samples to $n=16$. **Edit the code used in parts c and d rather than write code from scratch.**


{
  "hash": "842e5d6050d2bef3082752d8a90fe585",
  "result": {
    "markdown": "---\ntitle: \"Fundamentals of Working with Data\"\nauthor: 'Adam Spiegler, University of Colorado Denver'\noutput:\n  html_document:\n#    toc: yes\n#    toc_depth: 1\n#    theme: cerulean\n#jupyter:\n#  kernelspec:\n#    display_name: R\n#    language: R\n#    name: ir\n#output:\n#    ipynbdocument::ipynb_document\n---\n\n\n\n[![Open In Colab](https://colab.research.google.com/assets/colab-badge.svg)](https://githubtocolab.com/CU-Denver-MathStats-OER/Statistical-Theory/blob/main/Appendix/Intro-to-Vectors-Dataframes.ipynb) <nbsp> \n\n# Introduction {#sec-intro}\n\n---\n\nUnderstanding the data types of the variables in our data set, and the structure of our data is crucial before we can identify what aspects might need to be cleaned and transformed so we can perform statistical analysis more efficiently.\n\n\nThis notebook is intended to be a brief overview of some fundamentals of working with data in R.\n\n- [How to save and display output of from commands?](#sec-assign)\n- [What are the basic data types?](#sec-datatypes)\n- [How to convert data types?](#sec-changetype)\n- [What are the data structures in R?](#sec-structures)\n- How to [create](#sec-createdf) or [import](#sec-importing) a data frame?\n- [How to slice and extract rows and columns of a data frame?](#sec-extract)\n\nThese topics are important. This notebook just scratches the surface on many concepts. If you do not find a complete answer here, there are free resources online that dig deeper and more completely. Below are two such recommended references.\n\n- [An Introduction to R](https://cran.r-project.org/doc/manuals/r-release/R-intro.pdf) by the developers of R\n\n- [Programming with R Guide to Data Types and Structures](https://swcarpentry.github.io/r-novice-inflammation/13-supp-data-structures.html)\n\n\n## Loading Packages with the `library()` Command {#sec-load}\n\n---\n\n\nTo explore some fundamentals of working with data in R, we will use the `storms` data set which is located in the package `dplyr`.\n\n-   The `dplyr` package is already installed in Google Colaboratory\n-   We still need to use a `library` command to load the package.\n-   <span style=\"color:dodgerblue\">**Run the code cell below to load the `dplyr` package.**</span>\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# load the library of functions and data in dplyr\nlibrary(dplyr)\n```\n:::\n\n\n::: {.callout-caution}\nEach time you connect or restart a session, you will need to run a `library()` command in order to access data and scripts in a package.\n:::\n\n## Help Documentation {#sec-help}\n\n---\n\nThe functions introduced in this document have robust help documentation with lots of options to customize. If you want to view help documentation for any of the functions used in this document, run commands such`?typeof`, `?is.numeric`, `?read.table`, and so on.\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# access help documentation for storms\n?storms  # side panel should open with help manual for storms\n```\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\n# access help documentation for typeof\n?typeof\n```\n:::\n\n\n\n# Getting to Know Our Data {#sec-knowdata}\n\n---\n\nThe package `dplyr` contains a data set called `storms`. Letâ€™s find some useful information about this data.\n\n- The code cell below will provide a numeric summary of all variables in the `storms` data.\n- Recall we need to first run the command `library(dplyr)` in the code cell above to be able to access `storms`.\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# get a numerical summary of all variables\nsummary(storms)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n     name                year          month             day       \n Length:19066       Min.   :1975   Min.   : 1.000   Min.   : 1.00  \n Class :character   1st Qu.:1993   1st Qu.: 8.000   1st Qu.: 8.00  \n Mode  :character   Median :2004   Median : 9.000   Median :16.00  \n                    Mean   :2002   Mean   : 8.699   Mean   :15.78  \n                    3rd Qu.:2012   3rd Qu.: 9.000   3rd Qu.:24.00  \n                    Max.   :2021   Max.   :12.000   Max.   :31.00  \n                                                                   \n      hour             lat             long                         status    \n Min.   : 0.000   Min.   : 7.00   Min.   :-109.30   tropical storm     :6684  \n 1st Qu.: 5.000   1st Qu.:18.40   1st Qu.: -78.70   hurricane          :4684  \n Median :12.000   Median :26.60   Median : -62.25   tropical depression:3525  \n Mean   : 9.094   Mean   :26.99   Mean   : -61.52   extratropical      :2068  \n 3rd Qu.:18.000   3rd Qu.:33.70   3rd Qu.: -45.60   other low          :1405  \n Max.   :23.000   Max.   :70.70   Max.   :  13.50   subtropical storm  : 292  \n                                                    (Other)            : 408  \n    category          wind           pressure      tropicalstorm_force_diameter\n Min.   :1.000   Min.   : 10.00   Min.   : 882.0   Min.   :   0.0              \n 1st Qu.:1.000   1st Qu.: 30.00   1st Qu.: 987.0   1st Qu.:   0.0              \n Median :1.000   Median : 45.00   Median :1000.0   Median : 110.0              \n Mean   :1.898   Mean   : 50.02   Mean   : 993.6   Mean   : 146.3              \n 3rd Qu.:3.000   3rd Qu.: 65.00   3rd Qu.:1007.0   3rd Qu.: 220.0              \n Max.   :5.000   Max.   :165.00   Max.   :1024.0   Max.   :1440.0              \n NA's   :14382                                     NA's   :9512                \n hurricane_force_diameter\n Min.   :  0.00          \n 1st Qu.:  0.00          \n Median :  0.00          \n Mean   : 14.81          \n 3rd Qu.:  0.00          \n Max.   :300.00          \n NA's   :9512            \n```\n:::\n:::\n\n\n## Missing Data {#sec-na}\n\n------------------------------------------------------------------------\n\nA <span style=\"color:dodgerblue\">**missing value**</span> occurs when the value of something isn't known.\nR uses the special object `NA` to represent missing value. If you have a missing value, you should represent that value as `NA`. Note: The character string `\"NA\"` is not the same thing as `NA`.\n\n- The `storms` data has properly coded 14,382 missing values for `category` since storms that are not hurricanes do not have a category.\n- The `storms` data has properly coded 9,512 missing values for each of `tropicalstorm_force_diameter` and `hurricane_force_diameter` since these value only began being recorded in 2004.\n\n\n# Assignment to New (or Existing) Objects {#sec-assign}\n\n------------------------------------------------------------------------\n\nTo store a data structure in the computer's memory we must assign it a name.\n\nData structures can be stored using the assignment operator `<-` or `=`.\n\nSome comments:\n\n-   In general, both `<-` and `=` *can* be used for assignment.\n-   `<-` and `=` can be used identically most of the time, but not always.\n-   <span style=\"color:dodgerblue\">**It's safer and more conventional to use `<-` for assignment**</span>.\n\n\nIn the following code, we compute the mean of a vector.\n**Why can't we see the result after running it**?\n\n\n::: {.cell}\n\n```{.r .cell-code}\nw <- storms$wind  # wind is now stored in w\nxbar.w <- mean(w)  # compute mean wind speed and assign to xbar.w\n```\n:::\n\n\n-   Once an object has been assigned a name, it can be printed by executing the name of the object.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nxbar.w  # print the mean wind speed to screen\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 50.01741\n```\n:::\n:::\n\n\n\n-   We can also print an object to screen using the `print()` function. \n\n\n::: {.cell}\n\n```{.r .cell-code}\nprint(xbar.w)  # print the mean with print() command\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 50.01741\n```\n:::\n:::\n\n\n\n-   We can calculate, assign, and print the result by putting parenthesis around the assignment.\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# calculate, assign, and print standard deviation\n(s <- sd(w))  # note ( ) around the entire command\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 25.50103\n```\n:::\n:::\n\n\n-   **Sometimes you want to see the result of a code cell, and sometimes you will not.**\n\n# Basic Data Types {#sec-datatypes}\n\n------------------------------------------------------------------------\n\nR has 6 basic [data types](https://cran.r-project.org/doc/manuals/r-release/R-lang.html#Basic-types):\n\n1.  <span style=\"color:dodgerblue\">**character**</span>: collections of characters. E.g., `\"a\"`, `\"hello world!\"`\n2.  <span style=\"color:dodgerblue\">**double**</span>: decimal numbers. e.g., `1.2`, `1.0`\n3.  <span style=\"color:dodgerblue\">**integer**</span>: whole numbers. In R, you must add `L` to the end of a number to specify it as an integer. E.g., `1L` is an integer but `1` is a double.\n4.  <span style=\"color:dodgerblue\">**logical**</span>: Boolean values, `TRUE` and `FALSE`\n5.  <span style=\"color:dodgerblue\">**complex**</span>: complex numbers. E.g., `1+3i`\n6.  <span style=\"color:dodgerblue\">**raw**</span>: a type to hold raw bytes.\n\n## Checking Data Type Using `typeof()` {#sec-typeof}\n\n------------------------------------------------------------------------\n\n-   The `typeof()` function returns the R internal type or storage mode of any object.\n\n\n::: {.cell}\n\n```{.r .cell-code}\ntypeof(1.0)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] \"double\"\n```\n:::\n\n```{.r .cell-code}\ntypeof(2)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] \"double\"\n```\n:::\n\n```{.r .cell-code}\ntypeof(3L)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] \"integer\"\n```\n:::\n\n```{.r .cell-code}\ntypeof(\"hello\")\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] \"character\"\n```\n:::\n\n```{.r .cell-code}\ntypeof(TRUE)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] \"logical\"\n```\n:::\n\n```{.r .cell-code}\ntypeof(storms$status)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] \"integer\"\n```\n:::\n\n```{.r .cell-code}\ntypeof(storms$year)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] \"double\"\n```\n:::\n\n```{.r .cell-code}\ntypeof(storms$name)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] \"character\"\n```\n:::\n:::\n\n\n## Investigating Data Types with `is.numeric()` {#sec-isdatatype}\n\n------------------------------------------------------------------------\n\n-   The `is.numeric(x)` function tests whether or not an object `x` is numeric.\n-   The `is.character(x)` function tests whether `x` is a character or not.\n-   The `is.factor(x)` function tests whether `x` is a factor or not.\n\n::: {.callout-note}\nCategorical data is typically stored as a `factor` in R.\n:::\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nis.numeric(storms$year)  # year is numeric\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] TRUE\n```\n:::\n\n```{.r .cell-code}\nis.numeric(storms$category)  # category is also numeric\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] TRUE\n```\n:::\n\n```{.r .cell-code}\nis.numeric(storms$name)  # name is not numeric\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] FALSE\n```\n:::\n\n```{.r .cell-code}\nis.character(storms$name)  # name is character string\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] TRUE\n```\n:::\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\nis.numeric(storms$status)  # status is not numeric\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] FALSE\n```\n:::\n\n```{.r .cell-code}\nis.character(storms$status)  # status is not a character\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] FALSE\n```\n:::\n\n```{.r .cell-code}\nis.factor(storms$status)  # status is a factor which is categorical\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] TRUE\n```\n:::\n:::\n\n\n-   The function `str(x)` provides information about the levels or classes of `x`.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nstr(storms$status)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n Factor w/ 9 levels \"disturbance\",..: 7 7 7 7 7 7 7 7 8 8 ...\n```\n:::\n:::\n\n\n## Changing Data Types {#sec-changetype}\n\n------------------------------------------------------------------------\n\n### Converting to Categorical Data with `factor()` {#sec-factor}\n\n------------------------------------------------------------------------\n\n-   Sometimes we think a variable is one data type, but it is actually being stored (and thus interpreted by R) as a different data type.\n-   One common issue is categorical data is stored as characters. We would like observations with the same values to be group together.\n  - The `status` variable in `storms` is being properly stored as a `factor`!\n  - The `category` variable in `storms` is being stored as a `numeric` since it is ordinal.\n-   With ordinal categories, we may choose to keep it stored as `numeric`, or we may prefer to treat them as factors.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nsummary(storms$category)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n   Min. 1st Qu.  Median    Mean 3rd Qu.    Max.    NA's \n  1.000   1.000   1.000   1.898   3.000   5.000   14382 \n```\n:::\n:::\n\n\n\n- The summary of `category` computes statistics such as mean and median.\n- Typically with categorical data, we prefer to count how many observations are in each class of the variable.\n- In the code cell below, we convert `category` to a factor, and then observe the resulting summary.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nstorms$category <- factor(storms$category)\nsummary(storms$category)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n    1     2     3     4     5  NA's \n 2478   973   579   539   115 14382 \n```\n:::\n:::\n\n\n### Converting Data Types with `as.numeric()`, `as.integer()`, etc.  {#sec-astype}\n\n------------------------------------------------------------------------\n\nFrom the summary of the `storms` data set we first found above, we see that the variables `year` and `month` are being stored as `double`. These variables actually are integer values.\n\nWe can convert another variable of one format into another format using `as.[new_datatype]()`\n\n-   For example, to convert to year to `integer`, we use `as.integer(storms$year)`.\n-   To convert a data type to character, we can use `as.character(x)`.\n-   To convert to a decimal (`double`), we can use `as.numeric(x)`\n\n\n::: {.cell}\n\n```{.r .cell-code}\ntypeof(storms$year)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] \"double\"\n```\n:::\n\n```{.r .cell-code}\ntypeof(storms$month)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] \"double\"\n```\n:::\n\n```{.r .cell-code}\nstorms$year <- as.integer(storms$year)\nstorms$month <- as.integer(storms$month)\ntypeof(storms$year)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] \"integer\"\n```\n:::\n\n```{.r .cell-code}\ntypeof(storms$month)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] \"integer\"\n```\n:::\n:::\n\n\n# Data structures {#sec-structures}\n\n------------------------------------------------------------------------\n\nR operates on <span style=\"color:dodgerblue\">**data structures**</span>.\nA data structure is simply some sort of \"container\" that holds certain kinds of information\n\nR has 5 basic data structures:\n\n-   <span style=\"color:dodgerblue\">**vector**</span>: One dimensional object of a single data type.\n-   <span style=\"color:dodgerblue\">**matrix**</span>: Two dimensional object of a single data type.\n-   <span style=\"color:dodgerblue\">**array**</span>: $n$ dimensional object of a single data type.\n-   <span style=\"color:dodgerblue\">**data frame**</span>: Two dimensional object where each column can be a different data type.\n-   <span style=\"color:dodgerblue\">**list**</span>: An object that contains elements of different types like (and possibly another list inside it).\n\n[See R documentation](https://cran.r-project.org/doc/manuals/r-release/R-lang.html#List-objects) for more info.\n\n## Vectors {#sec-vectors}\n\n------------------------------------------------------------------------\n\nA <span style=\"color:dodgerblue\">**vector**</span> is a single-dimensional set of data of the same type.\n\n### Creating Vectors from Scratch {#sec-createvector}\n\n------------------------------------------------------------------------\n\nThe most basic way to create a vector is the combine function `c`. The following commands create vectors of type numeric, character, and logical, respectively.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nx1 <- c(1, 2, 5.3, 6, -2, 4)\nx2 <- c(\"one\", \"two\", \"three\")\nx3 <- c(TRUE, TRUE, FALSE, TRUE)\nx4 <- c(TRUE, 3.4, \"hello\")\ntypeof(x1)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] \"double\"\n```\n:::\n\n```{.r .cell-code}\ntypeof(x2)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] \"character\"\n```\n:::\n\n```{.r .cell-code}\ntypeof(x3)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] \"logical\"\n```\n:::\n\n```{.r .cell-code}\ntypeof(x4)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] \"character\"\n```\n:::\n:::\n\n\n-   We can check the data structure of an object using commands such as `is.vector()`, `is.list()`, `is.matrix()`, and so on.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nis.list(x1)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] FALSE\n```\n:::\n\n```{.r .cell-code}\nis.vector(x1)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] TRUE\n```\n:::\n\n```{.r .cell-code}\nis.list(x4)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] FALSE\n```\n:::\n\n```{.r .cell-code}\nis.vector(x4)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] TRUE\n```\n:::\n:::\n\n\n## Data Frames {#sec-dataframe}\n\n------------------------------------------------------------------------\n\n<span style=\"color:dodgerblue\">**Data frames**</span> are two-dimensional data objects and are the **fundamental** data structure used by most of R's libraries of functions and data sets.\n\n-   Tabular data is <span style=\"color:dodgerblue\">**tidy**</span> if each row corresponds to a different observation and column corresponds to a different variable.\n\nEach column of a data frame is a <span style=\"color:dodgerblue\">**variable**</span> (stored as a **vector**). If the variable:\n\n-   Is measured or counted by a number, it is a <span style=\"color:dodgerblue\">**quantitative**</span> or <span style=\"color:dodgerblue\">**numerical**</span> variable.\n-   Groups observations into different categories or rankings, it is a <span style=\"color:dodgerblue\">**qualitative**</span> or <span style=\"color:dodgerblue\">**categorical**</span> variable.\n\n### Creating Data Frames from Scratch {#sec-createdf}\n\n------------------------------------------------------------------------\n\nData frames are created by passing vectors into the `data.frame()` function.\n\nThe names of the columns in the data frame are the names of the vectors you give the `data.frame` function.\n\nConsider the following simple example.\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# create basic data frame\nd <- c(1, 2, 3, 4)\ne <- c(\"red\", \"white\", \"blue\", NA)\nf <- c(TRUE, TRUE, TRUE, FALSE)\ndf <- data.frame(d,e,f)\ndf\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n  d     e     f\n1 1   red  TRUE\n2 2 white  TRUE\n3 3  blue  TRUE\n4 4  <NA> FALSE\n```\n:::\n:::\n\n\n\n### Naming Column Headers {#sec-namecol}\n\n---\n\nThe columns of a data frame can be renamed using the `names()` function on the data frame.\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# name columns of data frame\nnames(df) <- c(\"ID\", \"Color\", \"Passed\")\ndf\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n  ID Color Passed\n1  1   red   TRUE\n2  2 white   TRUE\n3  3  blue   TRUE\n4  4  <NA>  FALSE\n```\n:::\n:::\n\n\n\nThe columns of a data frame can be named when you are first creating the data frame by using `[new_name] = [orig_vec_name]` for each vector of data.\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# create data frame with better column names\ndf2 <- data.frame(ID = d, Color = e, Passed = f)\ndf2\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n  ID Color Passed\n1  1   red   TRUE\n2  2 white   TRUE\n3  3  blue   TRUE\n4  4  <NA>  FALSE\n```\n:::\n:::\n\n\n## Checking Data Structure {#sec-checkstructure}\n\n------------------------------------------------------------------------\n\n-   The `is.matrix(x)` function tests whether or not an object `x` is a matrix.\n-   The `is.vector(x)` function test whether `x` is a vector.\n-   The `is.data.frame(x)` function test whether `x` is a data frame.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nis.matrix(df)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] FALSE\n```\n:::\n\n```{.r .cell-code}\nis.vector(df)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] FALSE\n```\n:::\n\n```{.r .cell-code}\nis.data.frame(df)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] TRUE\n```\n:::\n:::\n\n\n# Extracting and Slicing Data Frames {#sec-extract}\n\n------------------------------------------------------------------------\n\n## Extracting a Column By Name {#sec-extractname}\n\n---\n\nThe column vectors of a data frame may be extracted using `$` and specifying the name of the desired vector.\n\n-   `df$Color` would access the `Color` column of data frame `df`.\n\n\n::: {.cell}\n\n```{.r .cell-code}\ndf$Color  # prints column of data frame df named Color\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] \"red\"   \"white\" \"blue\"  NA     \n```\n:::\n:::\n\n\n## Slicing Rows and Columns By Indexing {#sec-indexing}\n\n---\n\nPart of a data frame can also be extracted by thinking of at as a general matrix and specifying the desired rows or columns in square brackets after the object name.\n\n-   <span style=\"color:dodgerblue\">**Note R starts with index 1 which is different from Python which indexes starting from 0.**</span>\n\nFor example, if we had a data frame named `df`:\n\n-   `df[1,]` would access the first row of `df`.\n-   `df[1:2,]` would access the first two rows of `df`.\n-   `df[,2]` would access the second column of `df`.\n-   `df[1:2, 2:3]` would access the information in rows 1 and 2 of columns 2 and 3 of `df`.\n\n\n::: {.cell}\n\n```{.r .cell-code}\ndf[,2]  # second column is Color\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] \"red\"   \"white\" \"blue\"  NA     \n```\n:::\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\ndf[2,]  # second row of df\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n  ID Color Passed\n2  2 white   TRUE\n```\n:::\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\ndf[1:2,2:3]  # first and second rows of columns 2 and 3\n```\n:::\n\n\nIf you need to select multiple columns of a data frame by name, you can pass a character vector with column names in the column position of `[]`.\n\n-   `df[, c(\"ID\", \"Passed\")]` would extract the `ID` and `Passed` columns of `df`.\n\n\n::: {.cell}\n\n```{.r .cell-code}\ndf[, c(\"ID\", \"Passed\")]\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n  ID Passed\n1  1   TRUE\n2  2   TRUE\n3  3   TRUE\n4  4  FALSE\n```\n:::\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\ndf[, c(1, 3)]  # another we to pick columns 1 and 3\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n  ID Passed\n1  1   TRUE\n2  2   TRUE\n3  3   TRUE\n4  4  FALSE\n```\n:::\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\n# another we to pick columns 1 and 3\ndf[, -2]  # exclude column 2\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n  ID Passed\n1  1   TRUE\n2  2   TRUE\n3  3   TRUE\n4  4  FALSE\n```\n:::\n:::\n\n\n# Importing an External File as a Data Frame {#sec-importing}\n\n------------------------------------------------------------------------\n\nThe `read.table` function imports data from file into R as a data frame.\n\nUsage: `read.table(file, header = TRUE, sep = \",\")`\n\n-   `file` is the file path and name of the file you want to import into R.\n    -   If you don't know the file path, set `file = file.choose()` will bring up a dialog box asking you to locate the file you want to import.\n-   `header` specifies whether the data file has a header (variable labels for each column of data in the first row of the data file).\n    -   If you don't specify this option in R or use `header = FALSE`, then R will assume the file doesn't have any headings.\n    -   `header = TRUE` tells R to read in the data as a data frame with column names taken from the first row of the data file.\n-   `sep` specifies the delimiter separating elements in the file.\n    -   If each column of data in the file is separated by a space, then use `sep = \" \"`\n    -   If each column of data in the file is separated by a comma, then use `sep = \",\"`\n    -   If each column of data in the file is separated by a tab, then use `sep = \"\\t\"`.\n\nHere is an example reading a csv (comma separated file) with a header:\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# import data as data frame\nbike.store <- read.table(file=\"https://raw.githubusercontent.com/CU-Denver-MathStats-OER/Statistical-Theory/main/Data/Transactions.csv\",\n                         header = TRUE,  # Keep column headers as names\n                         sep = \",\")  # comma as separator of columns\n\nglimpse(bike.store)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nRows: 20,000\nColumns: 13\n$ transaction_id          <int> 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14,â€¦\n$ product_id              <int> 2, 3, 37, 88, 78, 25, 22, 15, 67, 12, 5, 61, 3â€¦\n$ customer_id             <int> 2950, 3120, 402, 3135, 787, 2339, 1542, 2459, â€¦\n$ transaction_date        <chr> \"25-02-2017\", \"21-05-2017\", \"16-10-2017\", \"31-â€¦\n$ online_order            <lgl> FALSE, TRUE, FALSE, FALSE, TRUE, TRUE, TRUE, Fâ€¦\n$ order_status            <chr> \"Approved\", \"Approved\", \"Approved\", \"Approved\"â€¦\n$ brand                   <chr> \"Solex\", \"Trek Bicycles\", \"OHM Cycles\", \"Norcoâ€¦\n$ product_line            <chr> \"Standard\", \"Standard\", \"Standard\", \"Standard\"â€¦\n$ product_class           <chr> \"medium\", \"medium\", \"low\", \"medium\", \"medium\",â€¦\n$ product_size            <chr> \"medium\", \"large\", \"medium\", \"medium\", \"large\"â€¦\n$ list_price              <dbl> 71.49, 2091.47, 1793.43, 1198.46, 1765.30, 153â€¦\n$ standard_cost           <dbl> 53.62, 388.92, 248.82, 381.10, 709.48, 829.65,â€¦\n$ product_first_sold_date <int> 41245, 41701, 36361, 36145, 42226, 39031, 3416â€¦\n```\n:::\n:::\n\n\n- The `glimpse()` function provides a nice summary of the structure.\n- Run the code cell below to see the various options of `read.table()`.\n- There are other functions and packages that may be better at reading in tabular data. `read.table()` is a good place to start!\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n?read.table\n```\n:::\n\n\n\n# Logical Statements {#sec-logical}\n\n------------------------------------------------------------------------\n\n\nSometimes we need to know if the elements of an object satisfy certain conditions.\nThis can be determined using the logical operators `<`, `<=`, `>`, `>=`, `==`, `!=`.\n\n-   `==` means equal to.\n-   `!=` means NOT equal to.\n\nExecute the following commands in R and see what you get.\n\n\n::: {.cell}\n\n```{.r .cell-code}\na <- seq(2, 16, by = 2) # creating the vector a\na\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1]  2  4  6  8 10 12 14 16\n```\n:::\n\n```{.r .cell-code}\na > 10\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] FALSE FALSE FALSE FALSE FALSE  TRUE  TRUE  TRUE\n```\n:::\n\n```{.r .cell-code}\na <= 4\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1]  TRUE  TRUE FALSE FALSE FALSE FALSE FALSE FALSE\n```\n:::\n\n```{.r .cell-code}\na == 10\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] FALSE FALSE FALSE FALSE  TRUE FALSE FALSE FALSE\n```\n:::\n\n```{.r .cell-code}\na != 10\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1]  TRUE  TRUE  TRUE  TRUE FALSE  TRUE  TRUE  TRUE\n```\n:::\n:::\n\n\n## And and Or Statements {#sec-andor}\n\n------------------------------------------------------------------------\n\nMore complicated logical statements can be made using `&` and `|`.\n\n-   `&` means \"and\"\n    -   Both statements must be true for `state1 & state2` to return `TRUE`.\n-   `|` means \"or\"\n    -   Only one of the the two statements must be true for `state1 | state2` to return `TRUE`.\n    - If both statements are true in an \"or\" statement, the statement is also `TRUE`.\n\nBelow is a summary of \"and\" and \"or\" logic:\n\n-   `TRUE & TRUE` returns `TRUE`\n-   `FALSE & TRUE` returns `FALSE`\n-   `FALSE & FALSE` returns `FALSE`\n-   `TRUE | TRUE` returns `TRUE`\n-   `FALSE | TRUE` returns `TRUE`\n-   `FALSE | FALSE` returns `FALSE`\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# relationship between logicals & (and), | (or)\nTRUE & TRUE\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] TRUE\n```\n:::\n\n```{.r .cell-code}\nFALSE & TRUE\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] FALSE\n```\n:::\n\n```{.r .cell-code}\nFALSE & FALSE\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] FALSE\n```\n:::\n\n```{.r .cell-code}\nTRUE | TRUE\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] TRUE\n```\n:::\n\n```{.r .cell-code}\nFALSE | TRUE\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] TRUE\n```\n:::\n\n```{.r .cell-code}\nFALSE | FALSE\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] FALSE\n```\n:::\n:::\n\n\nExecute the following commands in R and see what you get.\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nb <- 3  # b is equal to the number 3\n\n# complex logical statements\n(b > 6) & (b <= 10)  # FALSE and TRUE\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] FALSE\n```\n:::\n\n```{.r .cell-code}\n(b <= 4) | (b >= 12)  # TRUE or FALSE\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] TRUE\n```\n:::\n:::\n\n\n\n## Logical Indexing {#sec-logicindex}\n\n---\n\nWe can use a logical statement as an index to extract certain entries from a vector or data frame. For example, if we want to to know the `product_id` (column 2), `brand` (column 7), `product_line` (column 8), and `list_price` (column 11) of all transactions that have a `list_price` greater than \\$2,090, we can run the code cell below.\n\n- We use a logical index for the row to extract just the rows that have a `list_price` value strictly greater than 2090.\n- We indicate we want to keep just columns 2, 7 through 8, and 11 with the column index `c(2, 7:8, 11)`.\n- We store the results to a new data frame named `expensive`.\n- Finally, we print the first 6 rows of our new data frame with the `head()` function to check the results.\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nexpensive <- bike.store[bike.store$list_price > 2090, c(2, 7:8, 11)]\nhead(expensive)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n    product_id         brand product_line list_price\n2            3 Trek Bicycles     Standard    2091.47\n16           3 Trek Bicycles     Standard    2091.47\n69          38 Trek Bicycles     Standard    2091.47\n154          3 Trek Bicycles     Standard    2091.47\n165          3 Trek Bicycles     Standard    2091.47\n188          3 Trek Bicycles     Standard    2091.47\n```\n:::\n:::\n\n\n## Creative Commons License Information {#sec-cc}\n\n---\n\n![Creative Commons License](https://i.creativecommons.org/l/by-nc-sa/4.0/88x31.png) <nbsp>\n\n*Statistical Methods: Exploring the Uncertain* by [Adam Spiegler](https://github.com/CU-Denver-MathStats-OER/Statistical-Theory) is licensed under a [Creative Commons Attribution-NonCommercial-ShareAlike 4.0 International License](http://creativecommons.org/licenses/by-nc-sa/4.0/).\n\n\n",
    "supporting": [],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}